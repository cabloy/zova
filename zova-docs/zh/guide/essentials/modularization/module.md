# 模块

## 为什么要实现模块化体系？

不知你是否认同一个架构理念：如果要避免`香山`的形成，那就把`香`装进集装箱里。

在一个大型的 Web 业务系统当中，随着业务的增长和变更，为了避免代码失控，也有必要将系统拆分为一个个相对独立的模块，这就是 Zova 采用模块化体系的缘由。因此，在 Zova 中，实际的业务代码开发都是在模块中进行。

## 模块化体系的意义

### 业务层面

1. **业务解耦**：代码结构清晰，业务逻辑充分解耦
2. **业务逻辑复用**：以模块为开发单元，便于沉淀技术资产，便于在不同的系统中重复利用
3. **分工协作、团队开发**：将业务系统拆分成模块的组合，有利于开发任务的分解与分配

### 代码层面

4. **命名空间隔离**：模块的命名空间隔离机制有利于减少开发时的心智负担，当我们在为模块内部的组件、配置等资源进行变量命名时，不必担心此名称会与其他模块冲突，从而也可以使得变量命名更加精简、自然
5. **构建拆包更容易**：在 Zova 中，一个模块就是一个天然的拆包边界，在 build 构建时，自动打包成一个独立的异步 Chunk，告别 Vite 配置的烦恼，同时可以有效避免构建产物的碎片化。特别是在大型业务系统中，这种优势尤其明显

## 命名约定

为了实现命名空间隔离，Zova 对模块采用如下命名约定：

```bash
完整名: zova-module-{providerId}-{moduleName}
短名: {providerId}-{moduleName}
```

- providerId: 提供者 Id。可以将某个功能或者特性作为 providerId，比如：blog, dashboard 等等
- moduleName: 模块名称

## 新建模块

可以使用 cli 命令创建模块文件骨架，比如新建一个模块`test-home`：

```bash
$ zova :create:module test-home --template=basic --suite
```

- suite 选项指示该模块归属于哪个套件，可以为空

在创建完模块之后，别忘了重新安装依赖，以便让模块生效:

```bash
$ pnpm install --force
```
